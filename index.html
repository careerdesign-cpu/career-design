<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Viewer</title>
  <style>
    /* 스크롤바(드래그바) 숨김 */
    * { scrollbar-width: none; }
    *::-webkit-scrollbar { width: 0; height: 0; }

    html,body{
      height:100%;
      margin:0;
      background:#0b1220;
      color:#e5e7eb;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      overflow:hidden; /* body 스크롤 차단 */
    }

    .topbar{
      height:52px; display:flex; align-items:center; gap:10px;
      padding:0 12px; border-bottom:1px solid rgba(255,255,255,.08);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
      position:sticky; top:0; z-index:30;
      user-select:none;
    }
    .btn{
      height:34px; padding:0 10px; border-radius:10px; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06); color:#e5e7eb; cursor:pointer;
    }
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .input{
      height:34px; width:64px; border-radius:10px; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04); color:#e5e7eb; text-align:center;
    }
    .spacer{flex:1}
    .wrap{height:calc(100% - 52px); display:flex}

    .sidebar{
      width:220px; border-right:1px solid rgba(255,255,255,.08);
      overflow:auto; padding:10px; box-sizing:border-box;
    }

    /* 썸네일 */
    .thumb-wrap{
      width:100%;
      margin-bottom:10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      cursor:pointer;
      overflow:hidden;
      position:relative;
    }
    .thumb-wrap canvas{
      display:block;
      width:100%;
      height:auto;
      border:none; box-shadow:none; border-radius:0; background:transparent;
    }
    .thumb-wrap.active{
      border-color:#6366f1;
      box-shadow:0 0 0 2px #6366f155;
    }
    .thumb-wrap::before{
      content:""; position:absolute; inset:0;
      background:linear-gradient(90deg,transparent 25%,rgba(255,255,255,.06) 50%,transparent 75%);
      background-size:200% 100%;
      animation:shimmer 1.4s infinite;
    }
    .thumb-wrap.loaded::before{ display:none; }
    @keyframes shimmer{ to{ background-position:-200% 0; } }

    .viewer{
      flex:1;
      overflow:auto;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:16px;
      box-sizing:border-box;
      position:relative;
    }

    .canvas-wrap{
      position:relative;
      user-select:none;
      border-radius:12px;
    }

    /* 슬라이드 애니메이션(캔버스 2장) */
    .stage{
      position:relative;
      border-radius:12px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background:#111827;
      box-shadow:0 12px 50px rgba(0,0,0,.35);
      max-width:100%;
    }
    .stage canvas{
      position:absolute;
      left:0; top:0;
      width:100%;
      height:100%;
      display:block;
      border:none;
      box-shadow:none;
      border-radius:0;
      background:transparent;
      transform:translateX(0);
      pointer-events:none; /* ✅ 캔버스가 클릭 잡아먹지 않게 */
    }

    /* ✅ 화면을 반으로 나누는 클릭 영역 */
    .tap-zone{
      position:absolute; top:0; bottom:0;
      width:50%;
      z-index:20;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .tap-zone.left{ left:0; }
    .tap-zone.right{ right:0; }

    /* 좌/우 UI 버튼(원하면 숨겨도 됨) */
    .nav-zone{
      position:absolute;
      top:0; bottom:0;
      width:72px;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:25;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      pointer-events:auto;
    }
    .nav-zone.left{ left:0; }
    .nav-zone.right{ right:0; }

    .nav-btn{
      width:46px;
      height:46px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#e5e7eb;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:22px;
      backdrop-filter: blur(6px);
      opacity:.85;
      transition:transform .08s, opacity .12s;
    }
    .nav-zone:hover .nav-btn{ opacity:1; }
    .nav-zone:active .nav-btn{ transform:scale(.98); }

    .loading-overlay{
      position:absolute; inset:0; border-radius:12px;
      background:rgba(11,18,32,.7);
      display:flex; align-items:center; justify-content:center;
      font-size:14px; color:#9ca3af;
      z-index:15;
    }
    .loading-overlay.hidden{ display:none; }

    .msg{
      position:fixed; left:50%; top:70px; transform:translateX(-50%);
      padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.12);
      background:rgba(239,68,68,.15); color:#fecaca; display:none; z-index:50;
      max-width:min(820px, calc(100% - 24px)); white-space:pre-wrap;
    }
  </style>
</head>

<body>
  <div class="msg" id="msg"></div>

  <div class="topbar">
    <button class="btn" id="prev">◀</button>
    <div>
      <input class="input" id="page" value="1" />
      <span id="pageCount">/ ?</span>
    </div>
    <button class="btn" id="next">▶</button>
    <button class="btn" id="zoomOut">－</button>
    <button class="btn" id="zoomIn">＋</button>
    <div class="spacer"></div>
    <button class="btn" id="openPdf">PDF 직접열기</button>
  </div>

  <div class="wrap">
    <div class="sidebar" id="sidebar"></div>

    <div class="viewer" id="viewer">
      <div class="nav-zone left" id="navLeft" title="이전(← / Shift+Space)">
        <div class="nav-btn">‹</div>
      </div>
      <div class="nav-zone right" id="navRight" title="다음(→ / Space)">
        <div class="nav-btn">›</div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <div class="stage" id="stage">
          <canvas id="canvasA"></canvas>
          <canvas id="canvasB"></canvas>

          <!-- ✅ 스테이지를 좌/우 반으로 분할 클릭 -->
          <div class="tap-zone left" id="tapLeft" title="이전"></div>
          <div class="tap-zone right" id="tapRight" title="다음"></div>
        </div>

        <div class="loading-overlay" id="overlay">렌더링 중...</div>
      </div>
    </div>
  </div>

  <script src="vendor/pdf.min.js"></script>
  <script>
    const PDF_URL    = "assets/proposal.pdf";
    const WORKER_URL = "vendor/pdf.worker.min.js";

    const $ = (id) => document.getElementById(id);
    const msg = $("msg");
    const showMsg = (t) => { msg.textContent = t; msg.style.display = "block"; };
    const hideMsg = () => { msg.style.display = "none"; };

    if (!window.pdfjsLib) {
      showMsg("pdfjsLib is not defined\n\nvendor/pdf.min.js 확인 필요");
      throw new Error("pdfjsLib is not defined");
    }
    pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_URL;

    let pdfDoc      = null;
    let currentPage = 1;
    let scale       = 1.2;

    let busy = false;
    let pendingTarget = null; // 마지막으로 원하는 페이지(연타해도 마지막만)

    const SLIDE_MS = 190;

    const overlay = $("overlay");
    const sidebar = $("sidebar");
    const viewer  = $("viewer");
    const stage   = $("stage");

    const canvasA = $("canvasA");
    const canvasB = $("canvasB");
    const ctxA = canvasA.getContext("2d", { alpha:false });
    const ctxB = canvasB.getContext("2d", { alpha:false });

    let front = "A"; // 처음엔 A가 front

    const frontCanvas = () => (front === "A" ? canvasA : canvasB);
    const backCanvas  = () => (front === "A" ? canvasB : canvasA);
    const frontCtx    = () => (front === "A" ? ctxA : ctxB);
    const backCtx     = () => (front === "A" ? ctxB : ctxA);

    // 썸네일 lazy
    const thumbCache = new Map();
    let thumbObserver = null;
    const THUMB_TARGET_W = 160;

    function clampPage(n){
      if (!pdfDoc) return 1;
      return Math.max(1, Math.min(pdfDoc.numPages, n));
    }

    function setLayersIdle(){
      // ✅ 빈 캔버스가 위에 덮지 않도록 z-index 관리 + back는 화면 밖으로 빼기
      const f = frontCanvas();
      const b = backCanvas();
      f.style.zIndex = 2;
      b.style.zIndex = 1;
      f.style.transform = "translateX(0)";
      b.style.transform = "translateX(120%)"; // 화면 밖
      f.style.transition = "none";
      b.style.transition = "none";
    }

    function setNavUI() {
      $("prev").disabled = currentPage <= 1;
      $("next").disabled = currentPage >= pdfDoc.numPages;
      $("page").value = String(currentPage);
      $("pageCount").textContent = `/ ${pdfDoc.numPages}`;
      sidebar.querySelectorAll(".thumb-wrap").forEach((el, i) => {
        el.classList.toggle("active", i + 1 === currentPage);
      });
    }

    async function renderTo(pageNum, targetCanvas, targetCtx) {
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale });

      const w = Math.floor(viewport.width);
      const h = Math.floor(viewport.height);

      targetCanvas.width = w;
      targetCanvas.height = h;

      stage.style.width = w + "px";
      stage.style.height = h + "px";

      await page.render({ canvasContext: targetCtx, viewport }).promise;
    }

    function animateSlide(direction){
      return new Promise((resolve) => {
        // next: 오른쪽에서 들어오고, prev: 왼쪽에서 들어옴
        const inFrom = (direction === "next") ? 1 : -1;
        const outTo  = -inFrom;

        const f = frontCanvas();
        const b = backCanvas();

        // ✅ 애니중에는 incoming(back)을 위로
        f.style.zIndex = 2;
        b.style.zIndex = 3;

        f.style.transition = "none";
        b.style.transition = "none";

        f.style.transform = "translateX(0)";
        b.style.transform = `translateX(${inFrom * 100}%)`;

        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            f.style.transition = `transform ${SLIDE_MS}ms ease`;
            b.style.transition = `transform ${SLIDE_MS}ms ease`;
            f.style.transform = `translateX(${outTo * 100}%)`;
            b.style.transform = "translateX(0)";
          });
        });

        setTimeout(() => resolve(), SLIDE_MS + 30);
      });
    }

    async function renderPage(targetPage) {
      if (!pdfDoc) return;

      targetPage = clampPage(targetPage);
      if (targetPage === currentPage) return;

      if (busy) {
        pendingTarget = targetPage; // 연타 시 마지막 목표만 저장
        return;
      }

      busy = true;
      overlay.classList.remove("hidden");

      try {
        const direction = (targetPage > currentPage) ? "next" : "prev";

        // back에 미리 렌더
        await renderTo(targetPage, backCanvas(), backCtx());

        // 오버레이 숨기고 슬라이드
        overlay.classList.add("hidden");
        await animateSlide(direction);

        // swap
        front = (front === "A") ? "B" : "A";
        currentPage = targetPage;

        setLayersIdle();
        setNavUI();

        viewer.scrollTop = 0;

      } catch (e) {
        overlay.classList.add("hidden");
        showMsg("렌더링 에러:\n" + (e?.message || String(e)));
        console.error(e);
      } finally {
        overlay.classList.add("hidden");
        busy = false;

        if (pendingTarget !== null && pendingTarget !== currentPage) {
          const next = pendingTarget;
          pendingTarget = null;
          renderPage(next);
        } else {
          pendingTarget = null;
        }
      }
    }

    function goNext(){ if (pdfDoc) renderPage(currentPage + 1); }
    function goPrev(){ if (pdfDoc) renderPage(currentPage - 1); }

    async function renderThumb(wrap, pageNum) {
      if (thumbCache.has(pageNum)) return;
      thumbCache.set(pageNum, true);

      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale: 1 });

      const thumbScale = THUMB_TARGET_W / viewport.width;
      const tv = page.getViewport({ scale: thumbScale });

      const c = document.createElement("canvas");
      c.width  = Math.floor(tv.width);
      c.height = Math.floor(tv.height);

      await page.render({ canvasContext: c.getContext("2d", { alpha:false }), viewport: tv }).promise;

      wrap.style.aspectRatio = `${c.width} / ${c.height}`;
      wrap.appendChild(c);
      wrap.classList.add("loaded");
    }

    function buildThumbPlaceholders() {
      sidebar.innerHTML = "";
      thumbCache.clear();

      if (thumbObserver) thumbObserver.disconnect();

      thumbObserver = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          if (!entry.isIntersecting) continue;
          const wrap = entry.target;
          const pageNum = parseInt(wrap.dataset.page, 10);

          const run = () => renderThumb(wrap, pageNum);
          if ("requestIdleCallback" in window) requestIdleCallback(run, { timeout: 1200 });
          else setTimeout(run, 0);

          thumbObserver.unobserve(wrap);
        }
      }, { root: sidebar, rootMargin: "240px" });

      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const wrap = document.createElement("div");
        wrap.className = "thumb-wrap";
        wrap.dataset.page = String(i);
        wrap.title = `Page ${i}`;
        wrap.addEventListener("click", () => renderPage(i));
        sidebar.appendChild(wrap);
        thumbObserver.observe(wrap);
      }
    }

    async function loadPdf() {
      try {
        pdfDoc = await pdfjsLib.getDocument({
          url: PDF_URL,
          rangeChunkSize: 65536,
          disableAutoFetch: false,
          disableStream: false,
        }).promise;

        $("pageCount").textContent = `/ ${pdfDoc.numPages}`;

        overlay.classList.remove("hidden");

        // ✅ 첫 페이지를 front에 렌더
        await renderTo(1, frontCanvas(), frontCtx());
        currentPage = 1;

        // ✅ back 캔버스가 위에 덮지 않도록 즉시 정리
        setLayersIdle();

        overlay.classList.add("hidden");
        setNavUI();

        setTimeout(buildThumbPlaceholders, 0);

      } catch (e) {
        showMsg(
          "PDF 로딩 실패\n\n" +
          `- ${PDF_URL} 경로 확인\n` +
          `- ${WORKER_URL} 확인\n\n` +
          "에러:\n" + (e?.message || String(e))
        );
        console.error(e);
      }
    }

    // 상단 버튼
    $("prev").addEventListener("click", (e) => { e.stopPropagation(); goPrev(); });
    $("next").addEventListener("click", (e) => { e.stopPropagation(); goNext(); });

    $("zoomIn").addEventListener("click", async (e) => {
      e.stopPropagation();
      if (!pdfDoc || busy) return;
      scale = Math.min(3.0, scale + 0.15);
      overlay.classList.remove("hidden");
      await renderTo(currentPage, frontCanvas(), frontCtx());
      setLayersIdle();
      overlay.classList.add("hidden");
    });

    $("zoomOut").addEventListener("click", async (e) => {
      e.stopPropagation();
      if (!pdfDoc || busy) return;
      scale = Math.max(0.6, scale - 0.15);
      overlay.classList.remove("hidden");
      await renderTo(currentPage, frontCanvas(), frontCtx());
      setLayersIdle();
      overlay.classList.add("hidden");
    });

    $("page").addEventListener("keydown", (e) => {
      if (e.key !== "Enter" || !pdfDoc) return;
      const n = parseInt(e.target.value, 10);
      if (Number.isFinite(n)) renderPage(clampPage(n));
    });

    $("openPdf").addEventListener("click", (e) => {
      e.stopPropagation();
      window.open(PDF_URL, "_blank");
    });

    // 좌/우 UI 버튼
    $("navLeft").addEventListener("pointerdown", (e) => { e.preventDefault(); e.stopPropagation(); goPrev(); });
    $("navRight").addEventListener("pointerdown", (e) => { e.preventDefault(); e.stopPropagation(); goNext(); });

    // ✅ 스테이지 좌/우 반 클릭(빈 화면 포함 전체 영역)
    $("tapLeft").addEventListener("pointerdown", (e) => { e.preventDefault(); e.stopPropagation(); goPrev(); });
    $("tapRight").addEventListener("pointerdown", (e) => { e.preventDefault(); e.stopPropagation(); goNext(); });

    // ✅ 키보드 컨트롤(스크롤 완전 방지)
    document.addEventListener("keydown", (e) => {
      if (!pdfDoc) return;

      const tag = (document.activeElement && document.activeElement.tagName || "").toLowerCase();
      const isTyping = tag === "input" || tag === "textarea";

      if (e.code === "Space") {
        if (!isTyping) {
          e.preventDefault();
          e.stopPropagation();
          if (e.shiftKey) goPrev();
          else goNext();
        }
        return;
      }

      if (!isTyping && e.key === "ArrowRight") { e.preventDefault(); goNext(); return; }
      if (!isTyping && e.key === "ArrowLeft")  { e.preventDefault(); goPrev(); return; }
    }, { capture:true, passive:false });

    loadPdf();
  </script>
</body>
</html>