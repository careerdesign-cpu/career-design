<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Viewer</title>
  <style>
    /* 스크롤바(드래그바) 숨김 */
    * { scrollbar-width: none; }
    *::-webkit-scrollbar { width: 0; height: 0; }

    html,body{
      height:100%;
      margin:0;
      background:#0b1220;
      color:#e5e7eb;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      overflow:hidden; /* body 스크롤 자체 차단 */
    }

    .topbar{
      height:52px; display:flex; align-items:center; gap:10px;
      padding:0 12px; border-bottom:1px solid rgba(255,255,255,.08);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
      position:sticky; top:0; z-index:10;
      user-select:none;
    }
    .btn{
      height:34px; padding:0 10px; border-radius:10px; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06); color:#e5e7eb; cursor:pointer;
    }
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .input{
      height:34px; width:64px; border-radius:10px; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04); color:#e5e7eb; text-align:center;
    }
    .spacer{flex:1}
    .wrap{height:calc(100% - 52px); display:flex}

    .sidebar{
      width:220px; border-right:1px solid rgba(255,255,255,.08);
      overflow:auto; padding:10px; box-sizing:border-box;
    }

    /* 썸네일 플레이스홀더 */
    .thumb-wrap{
      width:100%; margin-bottom:10px; border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      cursor:pointer; overflow:hidden; position:relative;
      aspect-ratio: 210 / 297;
    }
    .thumb-wrap canvas{
      display:block; width:100%; height:auto;
      border:none; box-shadow:none; border-radius:0; background:transparent;
    }
    .thumb-wrap.active{
      border-color: #6366f1;
      box-shadow: 0 0 0 2px #6366f155;
    }
    .thumb-wrap::before{
      content:""; position:absolute; inset:0;
      background:linear-gradient(90deg,transparent 25%,rgba(255,255,255,.06) 50%,transparent 75%);
      background-size:200% 100%;
      animation:shimmer 1.4s infinite;
    }
    .thumb-wrap.loaded::before{ display:none; }
    @keyframes shimmer{ to{ background-position:-200% 0; } }

    .viewer{
      flex:1;
      overflow:auto;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:16px;
      box-sizing:border-box;
      position:relative;
    }

    .canvas-wrap{
      position:relative;
      user-select:none;
      border-radius:12px;
    }

    /* ✅ 슬라이드 애니메이션을 위한 캔버스 2장 */
    .stage{
      position:relative;
      border-radius:12px;
      overflow:hidden; /* 슬라이드 이동 시 밖으로 나가지 않게 */
      border:1px solid rgba(255,255,255,.10);
      background:#111827;
      box-shadow:0 12px 50px rgba(0,0,0,.35);
      max-width:100%;
    }
    .stage canvas{
      position:absolute;
      left:0; top:0;
      width:100%;
      height:100%;
      display:block;
      border:none;
      box-shadow:none;
      border-radius:0;
      background:transparent;
      transform:translateX(0);
    }

    .canvas-wrap .loading-overlay{
      position:absolute; inset:0; border-radius:12px;
      background:rgba(11,18,32,.7);
      display:flex; align-items:center; justify-content:center;
      font-size:14px; color:#9ca3af; transition:opacity .2s;
      z-index:5;
    }
    .canvas-wrap .loading-overlay.hidden{ opacity:0; pointer-events:none; }

    /* 좌/우 오버레이 네비 버튼 */
    .nav-zone{
      position:absolute;
      top:0;
      bottom:0;
      width:72px;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:15;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .nav-zone.left{ left:0; }
    .nav-zone.right{ right:0; }

    .nav-btn{
      width:46px;
      height:46px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#e5e7eb;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:22px;
      backdrop-filter: blur(6px);
      opacity:.85;
      transition:transform .08s, opacity .12s;
    }
    .nav-zone:hover .nav-btn{ opacity:1; }
    .nav-zone:active .nav-btn{ transform:scale(.98); }

    .msg{
      position:fixed; left:50%; top:70px; transform:translateX(-50%);
      padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.12);
      background:rgba(239,68,68,.15); color:#fecaca; display:none; z-index:20;
      max-width:min(820px, calc(100% - 24px)); white-space:pre-wrap;
    }
  </style>
</head>
<body>
  <div class="msg" id="msg"></div>

  <div class="topbar">
    <button class="btn" id="prev">◀</button>
    <div>
      <input class="input" id="page" value="1" />
      <span id="pageCount">/ ?</span>
    </div>
    <button class="btn" id="next">▶</button>
    <button class="btn" id="zoomOut">－</button>
    <button class="btn" id="zoomIn">＋</button>
    <div class="spacer"></div>
    <button class="btn" id="openPdf">PDF 직접열기</button>
  </div>

  <div class="wrap">
    <div class="sidebar" id="sidebar"></div>

    <div class="viewer" id="viewer">
      <div class="nav-zone left" id="navLeft" title="이전(← / Shift+Space)">
        <div class="nav-btn">‹</div>
      </div>
      <div class="nav-zone right" id="navRight" title="다음(→ / Space)">
        <div class="nav-btn">›</div>
      </div>

      <div class="canvas-wrap" id="canvasWrap" title="클릭하면 다음 페이지">
        <div class="stage" id="stage">
          <canvas id="canvasA"></canvas>
          <canvas id="canvasB"></canvas>
        </div>
        <div class="loading-overlay" id="overlay">렌더링 중...</div>
      </div>
    </div>
  </div>

  <script src="vendor/pdf.min.js"></script>
  <script>
    const PDF_URL    = "assets/proposal.pdf";
    const WORKER_URL = "vendor/pdf.worker.min.js";

    const $   = (id) => document.getElementById(id);
    const msg = $("msg");
    const showMsg = (t) => { msg.textContent = t; msg.style.display = "block"; };
    const hideMsg = () => { msg.style.display = "none"; };

    if (!window.pdfjsLib) {
      showMsg("pdfjsLib is not defined\n\nvendor/pdf.min.js 를 확인하세요.");
      throw new Error("pdfjsLib is not defined");
    }
    pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_URL;

    let pdfDoc      = null;
    let currentPage = 1;
    let scale       = 1.2;

    // 애니/렌더 상태
    let busy = false;         // 애니메이션 + 렌더 작업 중
    let pending = null;       // {page, dir}
    const SLIDE_MS = 180;     // 슬라이드 속도(원하면 220~280로)

    const overlay = $("overlay");
    const sidebar = $("sidebar");
    const viewer  = $("viewer");
    const canvasWrap = $("canvasWrap");
    const stage = $("stage");

    // 캔버스 2장 번갈아 사용
    const canvasA = $("canvasA");
    const canvasB = $("canvasB");
    const ctxA = canvasA.getContext("2d");
    const ctxB = canvasB.getContext("2d");
    let front = "A"; // 현재 화면에 보이는 캔버스
    const frontCanvas = () => front === "A" ? canvasA : canvasB;
    const backCanvas  = () => front === "A" ? canvasB : canvasA;
    const frontCtx    = () => front === "A" ? ctxA : ctxB;
    const backCtx     = () => front === "A" ? ctxB : ctxA;

    // 썸네일 lazy
    const thumbCache = new Map();
    let thumbObserver = null;

    function clampPage(n){
      if (!pdfDoc) return 1;
      return Math.max(1, Math.min(pdfDoc.numPages, n));
    }

    function setNavUI() {
      $("prev").disabled = currentPage <= 1;
      $("next").disabled = currentPage >= pdfDoc.numPages;
      $("page").value = String(currentPage);
      $("pageCount").textContent = `/ ${pdfDoc.numPages}`;
      sidebar.querySelectorAll(".thumb-wrap").forEach((el, i) => {
        el.classList.toggle("active", i + 1 === currentPage);
      });
    }

    async function renderTo(pageNum, targetCanvas, targetCtx) {
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale });

      // stage 크기(= 캔버스 픽셀) 맞추기
      const w = Math.floor(viewport.width);
      const h = Math.floor(viewport.height);

      targetCanvas.width = w;
      targetCanvas.height = h;

      // stage 자체 크기 (CSS 픽셀)도 동일 비율로 맞춤
      stage.style.width = w + "px";
      stage.style.height = h + "px";

      await page.render({ canvasContext: targetCtx, viewport }).promise;
      return { w, h };
    }

    function animateSlide(dir) {
      // dir: "next" or "prev"
      return new Promise((resolve) => {
        const inFrom = (dir === "next") ? 1 : -1; // 다음은 오른쪽에서 들어옴(+1), 이전은 왼쪽(-1)
        const outTo  = -inFrom;

        const f = frontCanvas();
        const b = backCanvas();

        // 시작 위치 세팅
        f.style.transition = "none";
        b.style.transition = "none";
        f.style.transform = "translateX(0)";
        b.style.transform = `translateX(${inFrom * 100}%)`;

        // 다음 프레임에 transition 적용 후 이동
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            f.style.transition = `transform ${SLIDE_MS}ms ease`;
            b.style.transition = `transform ${SLIDE_MS}ms ease`;
            f.style.transform = `translateX(${outTo * 100}%)`;
            b.style.transform = "translateX(0)";
          });
        });

        const done = () => {
          // 정리
          f.style.transition = "none";
          b.style.transition = "none";
          f.style.transform = "translateX(0)";
          b.style.transform = "translateX(0)";
          resolve();
        };

        setTimeout(done, SLIDE_MS + 20);
      });
    }

    async function renderPage(pageNum, dir = null) {
      if (!pdfDoc) return;

      pageNum = clampPage(pageNum);
      if (pageNum === currentPage) return;

      // 작업 중이면 큐에 1개만 저장
      if (busy) { pending = { page: pageNum, dir }; return; }
      busy = true;
      overlay.classList.remove("hidden");

      try {
        // 방향 결정(없으면 숫자 비교)
        const direction = dir || (pageNum > currentPage ? "next" : "prev");

        // 1) 백캔버스에 다음 페이지 먼저 렌더
        await renderTo(pageNum, backCanvas(), backCtx());

        // 2) 슬라이드 애니메이션
        overlay.classList.add("hidden"); // 애니 시작할 때 오버레이 숨김(원하면 유지 가능)
        await animateSlide(direction);

        // 3) front/back 스왑
        front = (front === "A") ? "B" : "A";
        currentPage = pageNum;

        // UI 갱신
        setNavUI();

        // 페이지 바뀔 때 뷰어 스크롤 최상단(원치 않으면 삭제)
        viewer.scrollTop = 0;

      } catch (e) {
        overlay.classList.add("hidden");
        showMsg("렌더링 에러:\n" + (e?.message || String(e)));
        console.error(e);
      } finally {
        overlay.classList.add("hidden");
        busy = false;

        // 대기 처리
        if (pending) {
          const nextJob = pending;
          pending = null;
          renderPage(nextJob.page, nextJob.dir);
        }
      }
    }

    function goNext(){
      if (!pdfDoc) return;
      renderPage(currentPage + 1, "next");
    }
    function goPrev(){
      if (!pdfDoc) return;
      renderPage(currentPage - 1, "prev");
    }

    async function renderThumb(wrap, pageNum) {
      if (thumbCache.has(pageNum)) return;
      thumbCache.set(pageNum, true);

      const page     = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale: 1 });
      const thumbScale = 190 / viewport.width;
      const tv   = page.getViewport({ scale: thumbScale });

      const c    = document.createElement("canvas");
      c.width    = Math.floor(tv.width);
      c.height   = Math.floor(tv.height);
      await page.render({ canvasContext: c.getContext("2d"), viewport: tv }).promise;

      wrap.appendChild(c);
      wrap.classList.add("loaded");
    }

    function buildThumbPlaceholders() {
      sidebar.innerHTML = "";
      thumbCache.clear();

      thumbObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return;
          const wrap = entry.target;
          const pageNum = parseInt(wrap.dataset.page, 10);
          renderThumb(wrap, pageNum);
          thumbObserver.unobserve(wrap);
        });
      }, { root: sidebar, rootMargin: "200px" });

      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const wrap = document.createElement("div");
        wrap.className = "thumb-wrap";
        wrap.dataset.page = String(i);
        wrap.title = `Page ${i}`;
        wrap.addEventListener("click", () => {
          // 썸네일 클릭은 방향 자동
          renderPage(i);
        });
        sidebar.appendChild(wrap);
        thumbObserver.observe(wrap);
      }
    }

    async function loadPdf() {
      try {
        pdfDoc = await pdfjsLib.getDocument({
          url: PDF_URL,
          rangeChunkSize: 65536,
          disableAutoFetch: false,
          disableStream: false,
        }).promise;

        $("pageCount").textContent = `/ ${pdfDoc.numPages}`;

        // 첫 페이지는 front 캔버스에 렌더
        overlay.classList.remove("hidden");
        await renderTo(1, frontCanvas(), frontCtx());
        overlay.classList.add("hidden");

        currentPage = 1;
        setNavUI();
        buildThumbPlaceholders();

      } catch (e) {
        showMsg(
          "PDF 로딩 실패\n\n" +
          `- ${PDF_URL} 경로 확인\n` +
          `- ${WORKER_URL} 확인\n\n` +
          "에러:\n" + (e?.message || String(e))
        );
        console.error(e);
      }
    }

    // 상단 버튼
    $("prev").addEventListener("click", goPrev);
    $("next").addEventListener("click", goNext);

    $("zoomIn").addEventListener("click", async () => {
      if (!pdfDoc || busy) return;
      scale = Math.min(3.0, scale + 0.15);
      overlay.classList.remove("hidden");
      // 현재 페이지를 front에 다시 렌더 (애니 없음)
      await renderTo(currentPage, frontCanvas(), frontCtx());
      overlay.classList.add("hidden");
      // 썸네일은 그대로(원하면 scale 바뀔 때 썸네일도 리빌드 가능)
    });

    $("zoomOut").addEventListener("click", async () => {
      if (!pdfDoc || busy) return;
      scale = Math.max(0.6, scale - 0.15);
      overlay.classList.remove("hidden");
      await renderTo(currentPage, frontCanvas(), frontCtx());
      overlay.classList.add("hidden");
    });

    $("page").addEventListener("keydown", async (e) => {
      if (e.key !== "Enter" || !pdfDoc) return;
      const n = parseInt(e.target.value, 10);
      if (Number.isFinite(n)) renderPage(clampPage(n));
    });

    $("openPdf").addEventListener("click", () => window.open(PDF_URL, "_blank"));

    // 좌/우 오버레이 버튼
    $("navLeft").addEventListener("click", (e) => { e.stopPropagation(); goPrev(); });
    $("navRight").addEventListener("click", (e) => { e.stopPropagation(); goNext(); });

    // 메인 화면 클릭 → 다음 페이지
    canvasWrap.addEventListener("click", () => goNext());

    // 키보드 컨트롤
    document.addEventListener("keydown", (e) => {
      if (!pdfDoc) return;

      const tag = (document.activeElement && document.activeElement.tagName || "").toLowerCase();
      const isTyping = tag === "input" || tag === "textarea";

      // Space → 다음 / Shift+Space → 이전 (기본 스크롤 방지)
      if (e.code === "Space") {
        if (!isTyping) {
          e.preventDefault();
          if (e.shiftKey) goPrev();
          else goNext();
        }
        return;
      }

      // 좌/우 → 페이지 이동
      if (!isTyping && e.key === "ArrowRight") { e.preventDefault(); goNext(); return; }
      if (!isTyping && e.key === "ArrowLeft")  { e.preventDefault(); goPrev(); return; }
    }, { passive:false });

    loadPdf();
  </script>
</body>
</html>